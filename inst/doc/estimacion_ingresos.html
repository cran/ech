<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Estimación de ingresos</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Estimación de ingresos</h1>



<p>La medición de los ingresos tiene un rezago de un mes ya que si el hogar fue encuestado, por ejemplo en marzo, en este mes se preguntó por los ingresos del mes pasado, es decir de febrero. A su vez, estos ingresos están expresados a precios corrientes, por lo cual, para hacerlos comparables entre los diferentes meses de la encuesta o de otros años es necesario llevarlos a una medida común. Para convertir los ingresos de precios corrientes a precios constantes debemos elegir un índice como puede ser el IPC (Índice de Precios al Consumo) o el IPAB (Índice de Precios de Alimentos y Bebidas) para construir un deflactor. Por ejemplo, para expresar los ingresos del hogar con la información de la ECH 2019, elegimos como mes base junio y como año base 2019 y como deflactor el IPC. Esto implica que debemos considerar los valores del IPC mensual desde diciembre 2018 a noviembre 2019.</p>
<p>Obtener los datos del IPC es bastante sencillo usando el paquete <code>ech</code>, para ello existe la fucnión de hecho la función <code>get_ipc()</code> que descarga el archivo de la web del INE y lo guarda en un formato tidy en el data frame <code>ipc_base2010</code>. La estructura del objeto es la siguiente:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">tail</span>(ech<span class="op">::</span>ipc_base2010)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="co">#&gt; # A tibble: 6 x 5</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="co">#&gt;   fecha      indice          mensual            acum_ano        acum_12_meses   </span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co">#&gt;   &lt;date&gt;     &lt;chr&gt;           &lt;chr&gt;              &lt;chr&gt;           &lt;chr&gt;           </span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">#&gt; 1 2019-07-01 197.94          0.760000000000000~ 6.070000000000~ 7.54            </span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co">#&gt; 2 2019-08-01 199.69          0.88               7               7.7599999999999~</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co">#&gt; 3 2019-09-01 200.72          0.520000000000000~ 7.559999999999~ 7.7800000000000~</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co">#&gt; 4 2019-10-01 202.2299999999~ 0.75               8.359999999999~ 8.3399999999999~</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="co">#&gt; 5 2019-11-01 203.0800000000~ 0.419999999999999~ 8.820000000000~ 8.4000000000000~</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="co">#&gt; 6 2019-12-01 203.0200000000~ -0.02999999999999~ 8.789999999999~ 8.7899999999999~</span></span></code></pre></div>
<p>La función que permite obtener un deflactor es la función deflate(), que a su vez, utiliza internamente la función <code>get_ipc()</code>. No utilizamos directamente ninguna de estas funciones, sino que la simplicidad de ech radica en que para calcular ingresos a precios constantes usamos la función <code>income_constant_prices()</code> la cual utiliza internamente las otras dos funciones ya mencionadas.</p>
<p>Antes de deflactar los ingresos del hogar, tenemos que tener cargado el objeto con los microdatos de la ECH.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">library</span>(ech)</span>
<span id="cb2-2"><a href="#cb2-2"></a>df &lt;-<span class="st"> </span><span class="kw">get_microdata</span>(<span class="dt">year =</span> <span class="dv">2019</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a>df &lt;-<span class="st"> </span><span class="kw">organize_names</span>(df)</span></code></pre></div>
<p>Las variables a tener en cuenta en esta parte son:</p>
<ul>
<li><code>ht11</code>: Ingreso total del hogar con valor locativo sin servicio doméstico</li>
<li><code>ht13</code>: Valor locativo</li>
<li><code>ht19</code>: Cantidad de personas sin servicio doméstico</li>
<li><code>numero</code>: Identificador del hogar</li>
</ul>
<p>Para convertir los ingresos del hogar, que están medidos en la variable <code>ht11</code>, de precios corrientes a precios constantes, usamos la función <code>income_constant_prices()</code> y definimos sus parámetros: mes base (<code>base_month</code>), año base (<code>base_year</code>), el tipo de índice (<code>index</code>) que puede IPC o IPAB y el nivel del índice (<code>level</code>) que puede ser “G” (general) o “R” (regional que distingue entre Montevideo e Interior). Definimos como base enero de 2005.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>df &lt;-<span class="st"> </span><span class="kw">income_constant_prices</span>(<span class="dt">data =</span> df, <span class="dt">base_month =</span> <span class="dv">1</span>, <span class="dt">base_year =</span> <span class="dv">2005</span>, <span class="dt">index =</span> <span class="st">&quot;IPC&quot;</span>, <span class="dt">level =</span> <span class="st">&quot;G&quot;</span>)</span></code></pre></div>
<p>Esto crea una serie de variables:</p>
<ul>
<li><code>y_pc</code>: ingreso per cápita a precios corrientes</li>
<li><code>y_pc_d</code>: ingreso per cápita a precios constantes</li>
<li><code>rv_d</code>: valor locativo a precios constantes</li>
<li><code>y_wrv_d</code>: ingreso sin valor locativo a precios constantes</li>
<li><code>y_wrv_pc_d</code>: ingreso sin valor locativo per cápita a precios constantes</li>
</ul>
<p>Para obtener la estimación de alguna de estas variables usamos la función <code>get_estimation_mean()</code>, para estimar la media, <code>get_estimation_total()</code>, para estimar el total o <code>get_estimation_median()</code> para estimar la mediana. Estas funciones tienen algunos argumentos que refieren al diseño de muestreo como:</p>
<ul>
<li><code>numero</code>: se debe indicar la variable que identifica a los hogares</li>
<li><code>pesoano</code>: se debe indicar la variable uqe identifica los pesos asociados a cada hogar.</li>
<li><code>ids</code>: se debe indicar la variable que identifica a la unidades primarias de muestreo.</li>
<li><code>estrato</code>: se debe indicar la variable que identifica a los estratos.</li>
</ul>
<p>Para los microdatos de 2018 y 2019 la ECH pública cuenta con la información de las UPM y estratos. En la web del INE se encuentra en un archivo aparte pero la función <code>get_microdata()</code> ya la agrega a los microdatos que genera de manera que no es necesario hacer un merge entre ambas bases. Para años anteriores no están disponible estás variables en la base pública.</p>
<p>Es necesario definir <code>ids</code> y <code>estrato</code> que vienen con valor por defecto NULL, las demás se pueden dejar con sus valores por defecto, salvo que se usen registros de un mes o semestre en ese caso se debe cambiar el ponderador de los casos según corresponda.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">get_estimation_mean</span>(df, <span class="dt">variable =</span> <span class="st">&quot;y_pc_d&quot;</span>, <span class="dt">level =</span> <span class="st">&quot;i&quot;</span>, <span class="dt">ids =</span> <span class="st">&quot;upm&quot;</span>, <span class="dt">estrato =</span> <span class="st">&quot;estrato&quot;</span>)</span></code></pre></div>
<p>Para estimar el ingreso medio de los hogares a precios constantes de enero 2005 según departamento, se debe definir en el argumento by.x la variable “nomdpto”</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># Estimación de ingresos promedio per cápita a pesos constantes de ene/05 según dpto</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">get_estimation_mean</span>(df, <span class="dt">variable =</span> <span class="st">&quot;y_pc_d&quot;</span>, <span class="dt">by.x =</span> <span class="st">&quot;nomdpto&quot;</span>, <span class="dt">level =</span> <span class="st">&quot;i&quot;</span>, <span class="dt">ids =</span> <span class="st">&quot;upm&quot;</span>, <span class="dt">estrato =</span> <span class="st">&quot;estrato&quot;</span>)</span></code></pre></div>
<!-- Una forma de mostrar estos resultados es mediante un gráfico como el siguiente: -->
<p>Podemos comparar estos resultados con los publicados por el Observatorio Territorio Uruguay de OPP que se encuentran <a href="https://otu.opp.gub.uy/?q=listados/listados_datos_formato&amp;id=2727&amp;cant=0&amp;fecha=2019-01-01">aquí</a>.</p>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
